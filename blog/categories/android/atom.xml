<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Ubiratan Soares]]></title>
  <link href="http://ubiratansoares.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://ubiratansoares.github.io/"/>
  <updated>2014-05-13T23:06:26-03:00</updated>
  <id>http://ubiratansoares.github.io/</id>
  <author>
    <name><![CDATA[Ubiratan Soares]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Trazendo seu projeto para o Android Studio da maneira correta]]></title>
    <link href="http://ubiratansoares.github.io/blog/2014/05/12/trazendo-seu-projeto-para-o-android-studio-da-maneira-correta/"/>
    <updated>2014-05-12T20:05:49-03:00</updated>
    <id>http://ubiratansoares.github.io/blog/2014/05/12/trazendo-seu-projeto-para-o-android-studio-da-maneira-correta</id>
    <content type="html"><![CDATA[<p>Tenho defendido recentemente - veja, é a minha humilde opinião - que o Eclipse como ambiente para o desenvolvimento Android está com os dias contados. </p>

<p>Talvez essa seja uma opinião radical para o atual momento, visto que o Eclipse é muito utilizado - em especial pelos iniciantes - e de alguma forma melhor divulgado na literatura técnica; contudo, o fato é que o Eclipse já não se mostra a opção de melhor produtividade para o desenvolvedor Android mais experiente já há algum tempo, e o advento do <strong>Android Studio</strong> apenas simboliza isso de forma oficial. </p>

<!-- More -->

<p>Enquanto o aniversário de um ano do Android Studio não chega, vale salientar novamente que, enquanto <em>IDE</em>, ele é basicamente o que encontramos na sua ferramenta irmã, o <strong>IntelliJ IDEA</strong>, embora as distinções estejam se acentuando com o passar dos meses… </p>

<p>Penso que o maior valor agregado ao desenvolvedor não reside aí : reside sim no novo <strong>sistema de build</strong> que junto com uma versão do IDEA customizada compõe o Android Studio: estou falando dele, do <strong>Gradle</strong>.</p>

<p>Tenho comparado atualmente o Gradle com o <strong>Git</strong> : para o desenvolvedor, é mais uma ferramenta de produtividade não imediata, e mais uma curva de aprendizado a vencer. </p>

<p>As possibilidades na superfície do Gradle já são por demais interessantes, de modo que hoje acho impossível voltar atrás e trabalhar na antiga proposta do Eclipse, mesmo com as <em>builds</em> relativamente mais lentas do Gradle no meu modesto <em>hardware</em> do trabalho. </p>

<p>Acredito que essa é uma opinião compartilhada por muitos desenvelvodores, e não apenas diretantismo da minha cabeça….</p>

<h3 id="consideraes-iniciais">Considerações Iniciais</h3>

<p>Suponha que você decida trazer um dos seus projetos pessoais, ou melhor ainda, aquele projeto do trabalho para o Android Studio. </p>

<p>Se você quer ter o real valor agregado da solução que se chama Android Studio, eu suponho que você quer sentir o gostinho do Gradle. </p>

<p>O problema é que a opção de <strong>Import…</strong> do Android Studio com grande chance vai deixar a desejar em projetos maiores e mais antigos. Em especial, isso acontece com aqueles projetos típicos do Eclipse não muito bem estruturados (com várias bibliotecas <em>linkadas</em> manualmente por excelência). </p>

<p>Em geral, essa opção de <em>Import</em> vai compor o projeto no Android Studio como uma estrutura de módulos com <em>build</em> pela própria nos moldes típicos do IntelliJ, e não pelo Gradle de fato.</p>

<p>Mesmo hoje, na versão 0.5.8 do Android Studio, eu me deparo com a seguinte tela ao tentar importar um projeto :</p>

<p><img src="https://raw.githubusercontent.com/ubiratansoares/ubiratansoares.github.io/master/images/ss_gradle_import.png"></p>

<p>o que significa que ao final o projeto será importado na tradicional estrutura em módulos do IntelliJ, mas sem o suporte que queremos do Gradle…</p>

<p>Como proceder então?</p>

<h5 id="comear-com-um-novo-projeto-no-android-studio">Começar com um novo projeto no Android Studio</h5>

<p>Você pode criar um projeto no Android Studio do zero, o qual já irá trazer a estrutura de diretórios padrão já configurada bem como os arquivos já inicializados para o Gradle. </p>

<p>Você pode então manualmente migrar todas as suas classes e diretórios com <em>assets</em> para essa nova estrutura, não esquecendo de mapear as dependências (falaremos disso mais à frente). </p>

<p>Essa é uma abordagem direta e bastante utilizada. Eu considero ela como <strong>“Top-Down”</strong>. Serve muito bem para “sacudir a poeira”, atualizando as dependências do projeto ou mesmo descartando o que não é mais usado. Com certeza muito mais trabalhosa do que difícil… </p>

<p>O único problema que vejo com ela é : como fazemos com membros do time que ainda preferem usar o <strong>Eclipse</strong>, já que criamos na prática um outro projeto, em um outro ambiente ? Deixamos de lado? </p>

<p>Algumas vezes, isso não é uma opção, e devemos respeitar as preferências, mesmo as de IDE. <strong>:P</strong></p>

<h5 id="adicionar-suporte-ao-gradle-ao-projeto-j-existente">Adicionar suporte ao Gradle ao projeto já existente</h5>

<p>Você pode adicionar o suporte ao Gradle - e consequentemente ao Android Studio - em um projeto estruturado no Eclipse já em andamento de uma maneira mais artesanal, investigando como acertar cada um dos arquivos <strong>build.gradle</strong> nas bibliotecas de interesse e estudando as dependências para que o controle seja feito <strong>ao máximo</strong> pelo próprio Gradle. </p>

<p>Se assim o fizer, você executará um procedimento transparente para colegas do seu time, já que agora o projeto agora também é totalmente acessível e manipulável pelo Android Studio com a adição de apenas alguns arquivos do Gradle. </p>

<p>Essa abordagem eu considero mais como <strong>“Bottom-Up”</strong>, e é com certeza mais trabalhosa.</p>

<p>Eu tive recentemente a oportunidade de trazer alguns projetos do meu time que foram criados - e ganham continuidade - no Eclipse para o ambiente do Android Studio, pelo segundo caminho. Decidi, então, compartilhar aqui algumas das coisas que aprendi. </p>

<p>Espero que elas sejam úteis para quem trabalha em time como eu, e que eventualmente pretende utilizar essa experiência para perder o medo e convencer os amigos a deixar o Eclipse morrer em paz… <strong>:P</strong></p>

<h3 id="mapeando-dependncias">Mapeando Dependências</h3>

<p>Inicialmente, eu aconselho fortemente que você comece o seu processo de suporte ao Android Studio assim :</p>

<div><div class="CodeRay">
  <div class="code"><pre>&gt; git checkout -b gradle_build
Switched to a new branch 'gradle_build'
</pre></div>
</div>
</div>

<p>afinal de contas, temos o Git para nos auxiliar nos eventuais vacilos…</p>

<p>O primeiro passo para uma migração “Bottom-Up” é investigar as depedências do projeto. A idéia aqui é fazer um levantamento de tudo que queremos que Gradle controle de forma automatizada, buscando ao máximo utilizar artefatos atualizados advindos de repositórios <strong>Maven</strong>.</p>

<p>Eu não vou entrar na discussão sobre dependências do Gradle em si, mas a princípio podemos assumir que o Gradle é capaz de trabalhar de forma transparente com repositórios de artefatos do Maven, e isso é <strong>amplamente</strong> utilizado. </p>

<p>Nessa etapa, não vai ter muito como fugir de uma pesquisa nos repositórios do Github, verificando quais das suas bibliotecas Open Source já tinha um artefato disponível em algum repositório Maven.</p>

<p>No meu caso, eu também tive alguma “sorte”, pois todos os projetos que constavam como bibliotecas no Workspace do Eclipse estavam presentes no controle de versão, acessíveis hierarquicamente a partir do diretório-raiz do projeto :</p>

<div><div class="CodeRay">
  <div class="code"><pre>&gt; ls -la
total 32
drwxr-xr-x  18 bira  staff   612B May 12 16:39 ./
drwxr-xr-x  12 bira  staff   408B May 12 16:34 ../
drwxr-xr-x  13 bira  staff   442B May 12 16:30 .git/
drwxr-xr-x  18 bira  staff   612B May 12 16:02 ProjetoMobile/
drwxr-xr-x  11 bira  staff   374B May 12 16:02 Library-PullToRefresh/
drwxr-xr-x  13 bira  staff   442B May 12 16:02 Library-ShowCaseView/
drwxr-xr-x  15 bira  staff   510B May 12 16:02 Library-SmoothProgressBar/
drwxr-xr-x   8 bira  staff   272B May 12 16:02 Library-WizardPager/
drwxr-xr-x  12 bira  staff   408B May 12 16:02 UndoBar/
drwxr-xr-x  14 bira  staff   476B May 12 16:02 library-sugar/
drwxr-xr-x  13 bira  staff   442B May 12 16:02 library_DSVL/
drwxr-xr-x  14 bira  staff   476B May 12 16:02 library_ListViewAnimation/
</pre></div>
</div>
</div>

<p>Se esse for o seu caso, você já pode verificar inicialmente quais já possuem suporte ao Gradle para agilizar :</p>

<div><div class="CodeRay">
  <div class="code"><pre>&gt;  tree -fL 2 | grep build.gradle
│   ├── ./Library-PullToRefresh/build.gradle
│   ├── ./Library-ShowCaseView/build.gradle
│   ├── ./Library-SmoothProgressBar/build.gradle
│   ├── ./UndoBar/build.gradle
│   ├── ./library-sugar/build.gradle
│   ├── ./library_ListViewAnimation/build.gradle
</pre></div>
</div>
</div>

<p>e precisei também conferir os artefatos que temos na pasta <em>libs</em> :</p>

<div><div class="CodeRay">
  <div class="code"><pre>&gt; ls -la ProjetoMobile/libs/
total 2632
drwxr-xr-x   9 bira  staff   306B May 12 16:02 ./
drwxr-xr-x  18 bira  staff   612B May 12 16:02 ../
-rw-r--r--   1 bira  staff   607K May 12 16:02 android-support-v4.jar
-rw-r--r--   1 bira  staff    32K May 12 16:02 butterknife-4.0.1.jar
-rw-r--r--   1 bira  staff    45K May 12 16:02 datecs.jar
-rw-r--r--   1 bira  staff    60K May 12 16:02 ndeftools-1.2.4.jar
-rw-r--r--   1 bira  staff    77K May 12 16:02 picasso-2.1.1.jar
</pre></div>
</div>
</div>

<p>de modo que, complementando com a inspeção do arquivo <em>.project</em> - que revela a utilização do <strong>Google Play Services</strong>, referenciado diretamente no diretório do Android SDK - contei 14 depedências no projeto.</p>

<p>Bom, como eu já comentei, a idéia é mover o máximo dessas dependências para o controle via Gradle, pois queremos atualizar essas dependendências de uma automática e por muitas vezes automática.</p>

<p>Dessa forma, fiz o seguinte levantamento preliminar :</p>

<p>(a) Quais artefatos do diretório <projeto>/libs podem ser adicionados via Maven?</projeto></p>

<p>Temos : </p>

<ul>
  <li>android-support-v4 : <strong>Disponível</strong></li>
  <li>ButterKnife : <strong>Disponível</strong></li>
  <li>Picasso : <strong>Disponível</strong></li>
  <li>Google Play Services : <strong>Disponível</strong></li>
  <li>NDefTools : <strong>Disponível</strong></li>
</ul>

<p>Apenas a biblioteca <strong>datecs.jar</strong> não era um artefato do tipo Maven devidamente gerenciado em algum repositório público, e optei por mantê-la como dependência local do projeto.</p>

<p>(b) Das bibliotecas adicionas como projetos via <em>Workspace</em> do Eclipse, quais podem ser gerenciadas via Maven ao invés de serem incluídas como <em>Project Libraries</em> ?</p>

<p>Inicialmente, fui informado de ante-mão que, para as bibliotecas associadas via <em>Workspace</em>, três delas sofreram alteração no código-fonte durante o desenvolvimento ( <strong>WizardPager</strong>, <strong>SugarORM</strong> e <strong>UndoBar</strong>), devidamente registrado no controle de versão. </p>

<p>Além disso, <strong>DragAndSortListView</strong> e <strong>WizardPager</strong> não possuem suporte ao Gradle. Dessa forma, compilei a listagem do que a princípio poderia ser movido para o gerenciador de dependências do Gradle</p>

<ul>
  <li>PullToRefresh : <strong>OK</strong></li>
  <li>ShowCaseView : <strong>OK</strong> </li>
  <li>Smooth ProgressBar : <strong>OK</strong></li>
  <li>Wizard Pager : <strong>Não OK</strong> </li>
  <li>UndoBar : <strong>Não OK</strong> </li>
  <li>SugarORM : <strong>Não OK</strong> </li>
  <li>ListViewAnimations : <strong>OK</strong></li>
  <li>DragAndSortListView : <strong>Não OK</strong> </li>
  <li>StickyListHeaders : <strong>OK</strong></li>
</ul>

<p>Como isso, estava pronto para começar o processo de migração.</p>

<h3 id="criando-arquivos-e-fazendo-o-bsico-da-build">Criando arquivos e fazendo o básico da build</h3>

<p>Uma vez feito o levantamento das dependências, devemos criar os arquivos do Gradle necessários para que o mesmo saiba resolver as dependências e compilar cada um dos projetos associados - ou daqui em diante, <strong>módulos</strong> - de interesse, bem como o projeto principal em si.</p>

<p>Para isso, devemos proceder basicamente da seguinte forma :</p>

<ol>
  <li>
    <p>Criar os arquivos necessários para o Gradle na raiz do projeto.</p>
  </li>
  <li>
    <p>Para cada um dos módulos que permanecerão fora do gerenciador de de dependências, criar ou atualizar o arquivo <strong>build.gradle</strong> na raiz desse módulo.</p>
  </li>
</ol>

<p>O primeiro passo é bastante tranquilo de ser executado. Em geral, o Gradle vai precisar de dois arquivos “globais” na raiz do projeto, <strong>settings.gradle</strong> e <strong>build.gradle</strong>. Repare que ao criar um novo projeto no Android Studio, ambos estão lá.</p>

<p>O primeiro, <strong>build.gradle</strong>, serve para mapear configurações válidas para todos as partes - ou módulos - da <em>build</em>. Em geral, ele é mais ou menos assim por padrão </p>

<div><div class="CodeRay">
  <div class="code"><pre>// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:0.9.+'
    }
}

allprojects {
    repositories {
        mavenCentral()
    }
}
</pre></div>
</div>
</div>

<p>mas pode ser <em>customizado</em> conforme o interesse. Um exemplo típico : adicionar novas <em>URLs</em> para repositórios de artefatos tipo Maven.</p>

<p>O segundo, <strong>settings.gradle</strong>, é utilizado a princípio para indicar quais diretórios farão parte da <em>build</em>. Nessa hora, indicamos apenas projetos que estão <em>linkados</em> via <em>Workspace</em> e que vão a princípio continuar assim … </p>

<p>Essa, portanto, é a abordagem de adicionar um projeto como biblioteca com código-fonte para projetos do Android Studio :</p>

<div><div class="CodeRay">
  <div class="code"><pre>include 'ProjetoMobile'
include ':library-sugar'
include ':Library-WizardPager'
include ':library_DSVL'
include ':UndoBar'
</pre></div>
</div>
</div>

<p>Além disso, devemos adicionar um arquivo <strong>build.gradle</strong> para o módulo do projeto em si. Nesse caso, iremos mapear todas as dependências que queremos que o próprio Gradle resolva, bem como o que está sendo referenciado como módulo também, além dos artefatos já remanescentes no diretório <em>libs</em> :</p>

<div><div class="CodeRay">
  <div class="code"><pre>apply plugin: 'android'

android {

    compileSdkVersion 19
    buildToolsVersion &quot;19.0.3&quot;

    defaultConfig {
        minSdkVersion 15
        targetSdkVersion 19
        versionCode 1
        versionName &quot;1.0&quot;
    }

    buildTypes {
        release {
            runProguard false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
        }
    }

    sourceSets {

        main {
            manifest.srcFile 'AndroidManifest.xml'
            java.srcDirs = ['src']
            resources.srcDirs = ['src']
            res.srcDirs = ['res']
            assets.srcDirs = ['assets']
        }

        debug.setRoot('build-types/debug')
        release.setRoot('build-types/release')
    }
}

dependencies {
    compile project(':library-sugar')
    compile project(':Library-WizardPager')
    compile project(':library_DSVL')
    compile project(':Library-ShowCaseView')
    compile project(':UndoBar')

    compile files('libs/datecs.jar')

    compile 'com.android.support:support-v4:19.1.+'
    compile 'com.jakewharton:butterknife:5.0.1'
        
...

}
</pre></div>
</div>
</div>

<p>Repare que, nas dependências acima, tenho os três casos possíveis : um <strong>.jar</strong> local, projetos biblioteca ao estilo Gradle e dependências para o próprio Gradle resolver, buscando em repositórios do tipo Maven.</p>

<p>Repare também que, além de referenciar a dependências, eu também preciso <em>ensinar</em> ao Gradle a nova <strong>estrutura de diretórios</strong> para a qual ele deve olhar durante o processo de <em>build</em> desse módulo, já que ela difere da padrão.</p>

<p>Isso é feito no seguinte trecho do script :</p>

<div><div class="CodeRay">
  <div class="code"><pre>    sourceSets {

        main {
            manifest.srcFile 'AndroidManifest.xml'
            java.srcDirs = ['src']
            resources.srcDirs = ['src']
            res.srcDirs = ['res']
            assets.srcDirs = ['assets']
        }
            ...
</pre></div>
</div>
</div>

<p>Esse em geral é um procedimento mais chato de fazer. </p>

<p>Além disso, isso terá que ser feito em cada um dos módulos…</p>

<h3 id="acertando-as-depedncias-modulares">Acertando as Depedências Modulares</h3>

<p>Até aqui, já adicionamos as dependências para serem controladas pelo Gradle para módulo “principal”, o nosso código de fato; chegou investigar melhor as dependências que adicionamos como <em>include</em> - ou aquelas que eu chamo de modulares - na <em>build</em>.</p>

<p>As perguntas básicas aqui devem ser :</p>

<ol>
  <li>
    <p>Todas as dependências são compiláveis via Gradle?</p>
  </li>
  <li>
    <p>Para as dependências que já possuem um <em>script</em> <strong>build.gradle</strong>, o mesmo se encontra devidamente atualizado ?</p>
  </li>
  <li>
    <p>Alguma das depedências possui outras dependências que o Gradle deve resolver?</p>
  </li>
</ol>

<p>No meu caso, <em>DragAndSortListView</em> e <em>WizardPager</em> não possuíam suporte ao Gradle, de modo que tive que adicionar na mão.</p>

<p>O grande problema dessa parte é : a estrutura de diretórios na qual a biblioteca está organizada em geral não é a padrão do Gradle, exatamente no caso do projeto original do Eclipse. Por exemplo, segue um snippet de como ficou o script para a biblioteca <a href="https://github.com/romannurik/Android-WizardPager">WizardPager</a>, do DevRel Roman Nurik, que estava estruturado como um projeto para build via Maven. </p>

<div><div class="CodeRay">
  <div class="code"><pre>buildscript {
        repositories {
            mavenCentral()
        }

        dependencies {
            classpath 'com.android.tools.build:gradle:0.9.+'
        }
    }

apply plugin: 'android-library'

dependencies {
    compile 'com.android.support:support-v4:19.1.+'
}

android {
    compileSdkVersion 19
    buildToolsVersion &quot;19.0.3&quot;
    sourceSets {
        main {
            manifest.srcFile 'LibWizardPager/AndroidManifest.xml'
            java.srcDirs = ['LibWizardPager/src']
            resources.srcDirs = ['LibWizardPager/src']
            res.srcDirs = ['LibWizardPager/res']
        }
    }
}
</pre></div>
</div>
</div>

<p>Para cada uma dos módulos acrescentados, é necessário fazer esse trabalho de (eventual) adição e (inexorável) inspeção. Ele deve assegurar :</p>

<ul>
  <li>Que o script declara esse módulo como uma biblioteca</li>
  <li>Que as versões do <em>plugin</em> do Android para o Gradle bem como as <strong>build-tools</strong> estão atualizadas de acordo com o seu SDK</li>
  <li>Que os diretórios com os <em>paths</em> de interesse estão mapeados caso não estejam na estrutura padrão do Gradle</li>
  <li>Que as dependências desse módulo estão devidamente declaradas</li>
</ul>

<p>Apenas uma dica : deixe para o Gradle resolver as redundâncias entre módulos declaradas mais de uma vez ao longo dos scripts. Uma das tarefas dele é justamente essa!</p>

<p>Se você seguiu os passos acima com cuidado e critério, você será capaz de executar com sucesso o primeiro comando do Gradle (diretamente da raiz do projeto) :</p>

<div><div class="CodeRay">
  <div class="code"><pre>&gt; gradle tasks
Parallel execution is an incubating feature.
Relying on packaging to define the extension of the main artifact has been deprecated and is scheduled to be removed in Gradle 2.0
:tasks

------------------------------------------------------------
All tasks runnable from root project
------------------------------------------------------------

Android tasks
-------------
androidDependencies - Displays the Android dependencies of the project
signingReport - Displays the signing info for each variant

Build tasks
-----------
assemble - Assembles all variants of all applications and secondary packages.
assembleDebug - Assembles all Debug builds
assembleDebugTest - Assembles the Test build for the Debug build
assembleRelease - Assembles all Release builds
build - Assembles and tests this project.
buildDependents - Assembles and tests this project and all projects that depend on it.
buildNeeded - Assembles and tests this project and all projects it depends on.
clean - Deletes the build directory.

Build Setup tasks
-----------------
init - Initializes a new Gradle build. [incubating]
wrapper - Generates Gradle wrapper files. [incubating]

Help tasks
----------
dependencies - Displays all dependencies declared in root project 'ProjetoMobile'.
dependencyInsight - Displays the insight into a specific dependency in root project 'ProjetoMobile'.
help - Displays a help message
projects - Displays the sub-projects of root project 'ProjetoMobile'.
properties - Displays the properties of root project 'ProjetoMobile'.
tasks - Displays the tasks runnable from root project 'ProjetoMobile' (some of the displayed tasks may belong to subprojects).

Install tasks
-------------
installDebug - Installs the Debug build
installDebugTest - Installs the Test build for the Debug build
uninstallAll - Uninstall all applications.
uninstallDebug - Uninstalls the Debug build
uninstallDebugTest - Uninstalls the Test build for the Debug build
uninstallRelease - Uninstalls the Release build

Verification tasks
------------------
check - Runs all checks.
connectedAndroidTest - Installs and runs the tests for Build 'debug' on connected devices.
connectedCheck - Runs all device checks on currently connected devices.
deviceCheck - Runs all device checks using Device Providers and Test Servers.
lint - Runs lint on all variants.
lintDebug - Runs lint on the Debug build
lintRelease - Runs lint on the Release build

To see all tasks and more detail, run with --all.

BUILD SUCCESSFUL

Total time: 5.155 secs
</pre></div>
</div>
</div>

<p>ou seja, o Gradle conseguiu efetivamente gerar todas as tarefas associadas da sua <em>build</em>! </p>

<p>Agora é só correr para o abraço! (ou quase isso …)</p>

<h3 id="resolvendo-os-erros-da-build">Resolvendo os erros da build</h3>

<p>Nesse momento, você pode querer executar a <em>build</em> do seu projeto com </p>

<div><div class="CodeRay">
  <div class="code"><pre>&gt; gradle build
</pre></div>
</div>
</div>

<p>ou então construir diretamente os <strong>apks</strong> da aplicação via</p>

<div><div class="CodeRay">
  <div class="code"><pre>&gt; gradle assemble
</pre></div>
</div>
</div>

<p>e algo inesperado pode - ou vai - acontecer : o projeto que antes rodava certinho no Eclipse agora falha ao <em>buildar</em> no Gradle…</p>

<p>Há diversos motivos pelos quais isso pode acontecer. Vou tentar listar alguns dos mais comuns</p>

<ol>
  <li>
    <p>Para algum arquivo <strong>build.gradle</strong> de alguma dependência modular, o Gradle não reconheceu os diretórios de interesse, devido a algum erro de mapeamento nos <em><strong>sourceSets</strong></em> .</p>
  </li>
  <li>
    <p>Houve algum erro de checagem do <strong>Lint</strong>, o que interrompe o processo de <em>build</em>.</p>
  </li>
  <li>
    <p>Houve algum erro de compilação.</p>
  </li>
  <li>
    <p>Alguma <em>task</em> que não possui equivalente na <em>build</em> incremental do Eclipse falhou.</p>
  </li>
  <li>
    <p>Dentre outros …</p>
  </li>
</ol>

<p>O erro do tipo (1) é questão de prática, paciência e cuidado para ser resolvido, e o procedimento de inspeção do <em>script</em> Gradle para cada módulo brevemente explicado na seção anterior pode ajudar.</p>

<p>O erro do tipo (2) é infinitamente mais chato, afinal, no Eclipse conseguimos compilar mesmo com os <em>warnings</em> do Lint … </p>

<p>Para ignorá-los, você pode adicionar diretivas para que as tarefas de execução do Lint não sejam abortadas para o módulo de interesse : </p>

<div><div class="CodeRay">
  <div class="code"><pre>apply plugin: 'android'

android {

    lintOptions {
            abortOnError false
            warningsAsErrors false
    }

        ...
</pre></div>
</div>
</div>

<p>Uma série de parâmetros para essa diretiva estão relacionados na <a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Lint-support">documentação oficial</a>.</p>

<p>O ideal mesmo seria não precisar esquentar a cabeça com <em>warnings</em> do Lint…</p>

<p>O erro do tipo (3) é também comum. Uma situação que eu peguei foram <em>imports</em> não utilizados que o Eclipse aparentemente ignora ao compilar, mas que na <em>build</em> via Gradle causam erro … :/</p>

<p>Uma outra situação possível seria você confiar em um <em>script</em> <strong>build.gradle</strong> já presente em um módulo de interesse e que aparentemente está em ordem, mas que faz uso do <strong>Java 7.0</strong> no processo de compilação, e esse eventualmente não está disponível como JDK na máquina (sim, há situações em que isso pode acontecer, <strong>AINDA</strong>!)</p>

<p>O erro do tipo (4) pode ocorrer em diversos cenários. Um dos que eu gostaria de destacar é que o plugin do Gradle para o Android prevê uma <em>task</em> que, dentro das suas checagens, verifica se os <strong>9-patchs</strong> da aplicação estão bem formados; ou seja, você pode descobrir que alguns das imagens do seu projeto continham <em>bad patches</em> e a princípio vai precisar atualizá-las para que a <em>build</em> prossiga e para que o seu usuário não acha PNGs estranhos na sua aplicação …</p>

<h3 id="lies-aprendidas">Lições Aprendidas</h3>

<p>Depois desse artigo enorme, deu para ver que dá um trabalho razoável migrar de forma transparente um projeto Android a princípio estruturado no ambiente do Eclipse para o ambiente do Gradle (e consequentemente do Android Studio).</p>

<p>A opção <strong>“Generate Gradle Files”</strong>, acessível pelo Menu <strong>“Export…”</strong> do Eclipse se mostrou uma piada de mau-gosto na única vez em que tentei usá-la. Eu vou aconselhar a não confiar mais nela, pelo menos por enquanto.</p>

<p>O trabalho de levantamento de dependências e decisão sobre o que vai ainda permanecer como biblioteca/módulo da aplicação é entediante, porém importante. </p>

<p>Ele será tanto mais longo quanto maior o número de dependências tratadas de qualquer jeito na filosofia de trabalho típica do Eclipse : arquivos <strong>.jar</strong> no diretórios <em>libs</em> e <em>Project Libraries</em> associados via Workspace… </p>

<p>Quem já trabalhou em projetos em time ou mesmo projetos mais longos e sentiu os tipos de transtorno que isso causa implorava por uma boa solução, e isso explica por que tantos desenvolvedores confiaram por tanto tempo no <em>plugin</em> do Maven para Android … </p>

<p>Os tempos são outros, a agora enfim temos o Gradle, uma ferramenta que se alinha com o estado da arte de como um sistema de <em>build</em> deve realmente ser nos dias de hoje. </p>

<p>Em breve, devo montar algum material (provavelmente uma palestra) falando sobre as vantagens de se trabalhar com Gradle para a produtividade do desenvolvedor Android; afinal, não mencionei uma sequer aqui.</p>

<p>Gostaria de ter delineado mais esse artigo e tecido uma explicação mais detalhada sobre alguns pontos, mas realmente o tamanho dele superou as expectativas e paro por aqui. Se alguém encontrou algum erro, peço um comentário amigo para que o mesmo seja corrigido.</p>

<p>Para você que chegou até o fim, espero que eu tenha ajudado em alguma coisa! </p>

<p>Aquele abraço e até a próxima!</p>

]]></content>
  </entry>
  
</feed>
